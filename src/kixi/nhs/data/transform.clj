(ns kixi.nhs.data.transform
  "Collections of functions to transform data."
  (:require [kixi.ckan             :as ckan]
            [kixi.nhs.data.storage :as storage]
            [clojure.tools.logging :as log]
            [clj-time.core         :as t]
            [clj-time.format       :as tf]
            [clojure.edn           :as edn]
            [kixi.nhs.data.date    :as d]))

(defn not-nil? [x] (not (nil? x)))

(defn log-and-return [x]
  (log/info x)
  x)

(defn parse-number
  "Reads a number from a string. Returns nil if not a number
  or when the value passed is nil."
  [s]
  (when (not-nil? s)
    (let [parsed (clojure.string/replace s #"," "")]
      (when (re-find #"^-?\d+\.?\d*$" parsed)
        (edn/read-string parsed)))))

(defn get-value [k m]
  (-> (get m k)
      parse-number))

(defn outer-join
  "Combines data using specified field and function that acts on data with the same field value.
  Returns a sequence of maps, where each map respresents unique field
  and contains data combined from multiple datasets."
  [field data-fn colls]
  (let [lookup #(get % field)
        indexed (for [coll colls]
                  (into {} (map (juxt lookup identity) coll)))]
    (for [key (distinct (mapcat keys indexed))]
      (into {} (map #(data-fn key %) indexed)))))

(defn resource_id->description
  "Returns description of a resource with a specified id."
  [ckan-client resource_id]
  (:description (storage/get-resource-metadata ckan-client resource_id)))

(defn split-by-field-value
  "Creates a map of sequences, where key is a unique field, and value
  is a sequence containing all maps with that field. e.g.
  collection [{:v 5, :year 2010} {:v 4, :year 2010} {:v 0, :year 2009}]
  being split by :year results in:
  {2009 [{:v 0, :year 2009}], 2010 [{:v 5, :year 2010} {:v 4, :year 2010}]}"
  [field coll]
  (let [unique-values (distinct (map #(get % field) coll))
        accumulator   (zipmap unique-values (for [i unique-values] []))]
    (reduce (fn [acc m]
              (update-in acc [(get m field)] (fn [c] (conj c m))))
            accumulator coll)))

(defn remove-ids
  "Removes _id fields from the data that are generated by DataStore."
  [resource]
  (mapv #(dissoc % "_id") resource))

(def custom-formatter (tf/formatter "yyyyMMddHHmmss"))

(defn now->str
  "Formats the current timestamp into a string
  with date and time."
  []
  (let [now (t/now)]
    (tf/unparse custom-formatter now)))

(defn all-fields-exist?
  "Checks whether all fields are present in the first row
  of the table."
  [fields row]
  (let [headers (into #{} (keys row))]
    (every? #(contains? headers %) fields)))

;; Format percentage values:
(defn process-percentages
  "Takes a str indicator value and outputs
  a percentage in a str format."
  [value]
  (let [v (if (re-find #"%" value)
            (clojure.string/replace value #"%" "") value)]
    (-> v
        (Float/parseFloat)
        (/ 100)
        (str))))

(defmulti format-percentages (fn [data recipe]
                               (-> recipe :format :percentage)))

(defmethod format-percentages :none
  ;; Returns the value as passed in.
  [data recipe]
  data)

(defmethod format-percentages nil
  ;; Returns the value as passed in.
  [data recipe]
  data)

(defmethod format-percentages :divide
  ;; Divides it by 100.
  [data recipe]
  (update-in data [:value] process-percentages))

;; Calculate confidence intervals:
;; when several time periods in
;; the same data resource in ckan
(defn calculate-lci-uci
  [condition data]
  (if condition
    (let [sorted-data (reverse (sort-by :end_date data))
          current     (parse-number (:value (first sorted-data)))
          previous    (parse-number (:value (second sorted-data)))]
      (if (and current previous)
        (let  [difference (- current previous)
               ci         {:lci (when-not (nil? difference)
                                  (str (- current difference)))
                           :uci (when-not (nil? difference)
                                  (str (+ current difference)))}]
          (into [] (concat [(merge (first sorted-data) ci)]
                           (into [] (next sorted-data)))))
        data)) data))

(defn filter-dataset
  "Filters dataset according to the given recipe."
  [recipe-map data]
  (let [{:keys [conditions indicator-id fields-to-extract]} recipe-map]
    (keep (fn [d] (when (every? (fn [condition] (let [{:keys [field values]} condition]
                                                  ;; values is a set
                                                  (some values #{(get d field)})))
                                conditions)
                    (select-keys d fields-to-extract)))
          data)))

(defn enrich-map
  "Enriches map with indicator_id
  and makes sure period_coverage is not nil
  as it's a PK in CKAN."
  [recipe-map m]
  (let [{:keys [indicator-id metadata calculate-ci]} recipe-map]
    (-> m
        (merge metadata)
        (cond-> (empty? (:indicator_id m)) (assoc :indicator_id indicator-id))
        (cond-> (and (empty? (:period_of_coverage m))
                     (empty? (:period_of_coverage metadata)))
          (assoc :period_of_coverage (:year m)))
        (clojure.set/rename-keys (:fields-to-rename recipe-map))
        (format-percentages recipe-map)
        d/uniform-dates)))

(defn enrich-dataset
  "Enrichs dataset with indicator-id."
  [recipe-map data]
  (mapv #(enrich-map recipe-map %) data))

(defn split-by-key
  "Turns a sequence of maps into a sequence of sequences,
  where each nested sequence corresponds to a single group."
  [k data]
  (->> (group-by k data)
       vals))

(defn add-when-not-empty
  "Sums values in a sequence if it's not empty.
  Otherwise returns nil."
  [data]
  (when (seq data)
    (apply + (map parse-number data))))

(defn remove-fields
  [m fields]
  (apply dissoc m fields))

(defn sum-sequence
  "Retrieves all values for key k from a sequence
  and adds them up. Returns a map containing key 'sum'
  that contains the result of this calculation
  with other key value pairs coming from the first
  item in the sequence."
  [k fields-to-dissoc data]
  (-> data
      first
      (assoc :sum (->> data
                       (map k data)
                       (keep #(when (or (number? %)
                                        (seq %)) %))
                       add-when-not-empty))
      (remove-fields fields-to-dissoc)))

(defn divide
  "Divides two numbers. Guards against
  division by zero and nil values.
  Returns a numeric value."
  [n m]
  (when (and (not (nil? n))
             (not (nil? m))
             (not (zero? m)))
    (float (/ n m))))
